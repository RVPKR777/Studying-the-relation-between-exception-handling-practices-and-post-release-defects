"0","all_list = vector(""list"", 0)"
"0",""
"0","for (i in 1:length(projects)) {"
"0","  "
"0","  g = as.data.frame(git_data_list[i])"
"0","  u = as.data.frame(understand_data_list[i])"
"0","  th = as.data.frame(throws_data_list[i])"
"0","  c = as.data.frame(catch_data_list[i])"
"0","  tr = as.data.frame(try_data_list[i])"
"0","  "
"0"," "
"0","  th = rename(th, File.Path = Ã¯..File.Path)"
"0","  "
"0","  "
"0","  # Understand metrics for Java only: NA means real not applicable, since those don't exist in C#"
"0","  # Adding an extra category for valid non-applicable is suggested and accepted, according to Frank Harrell."
"0","  NAs_Other <- is.na(u)"
"0","  u[NAs_Other] <- -1"
"0","  "
"0","  # if (g$Project == ""nhibernate""){"
"0","  #   drop = c(""Language"")"
"0","  #   git_data = git_data[,!(names(git_data) %in% drop)]"
"0","  # }"
"0","  "
"0","  # Try metrics for Java only: NA means real not applicable, since those don't exist in C#"
"0","  # Adding an extra category for valid non-applicable is suggested and accepted, according to Frank Harrell."
"0","  NAs_Other <- is.na(tr$X..Method.Declaration)"
"0","  tr$X..Method.Declaration[NAs_Other] <- -1"
"0","  "
"0","  # Git + Understand"
"0","  g_u = merge(g,u, by = c(""File.Path"",""Project""))"
"0","  "
"0","  # Git + Understand + Throws"
"0","  g_u_t = merge(g_u, th, all.x = TRUE, by = c(""File.Path"",""Project""))"
"0","  "
"0","  # N of Throws: NA actually means 0 throws in that file."
"0","  NAs_N_Trows <- is.na(g_u_t$X..Throws)  "
"0","  g_u_t$X..Throws[NAs_N_Trows] <- 0"
"0","  "
"0","  # Throws APs: NA means real not applicable, since N Throws is zero."
"0","  # Adding an extra category for valid non-applicable is suggested and accepted, according to Frank Harrell."
"0","  NAs_Other <- is.na(g_u_t)"
"0","  g_u_t[NAs_Other] <- -1"
"0","  "
"0","  # Catch blocks + Try blocks"
"0","  # During data inspection we noticed that some catch blocks don't have related try blocks. (The other way around is not true)."
"0","  # That can happen because of non-identified possible exceptions for that try block. "
"0","  # However, in reality there should be always a try block for any catch block."
"0","  c_t = merge(c,tr, all.x = TRUE, by = c(""File.Path"",""Project""))"
"0","  "
"0","  # In this case we should not eliminate rows in which catch data is available, but no try data. We don't want to miss catch data, even if try data is missing."
"0","  # So, we flag these try blocks as real NAs that will be kept as NA for missing data analysis in the model construction."
"0","  NAs_Try_Blocks <- is.na(c_t)"
"0","  c_t[NAs_Try_Blocks] <- -9"
"0","  "
"0","  # (Git + Understand + Throws) + (Catch blocks + Try Blocks)"
"0","  g_u_t_c_t = merge(g_u_t, c_t, all.x = TRUE, by = c(""File.Path"",""Project""))"
"0","  "
"0","  # N of Catch: NA actually means 0 catchs in that file."
"0","  NAs_N_Catch <- is.na(g_u_t_c_t$X..Catch)"
"0","  "
"0","  #g_u_t_c_t$X..Catch[NAs_N_Catch] <- 0"
"0","  "
"0","  # Other Catch data: NA means real not applicable, since N Catch is zero."
"0","  # Adding an extra category for valid non-applicable is suggested and accepted, according to Frank Harrell."
"0","  NAs_Other <- is.na(g_u_t_c_t)"
"0","  g_u_t_c_t[NAs_Other] <- -1"
"0","  "
"0","  # Now we convert back the missing data due to catch without try blocks."
"0","  Missing_Try_Blocks <- g_u_t_c_t == -9"
"0","  g_u_t_c_t[Missing_Try_Blocks] <- NA"
"0","  "
"0","  # write.csv(g_u_t_c_t, file = ""g_u_t_c_t.csv"")"
"0","  # write.csv(c_t, file = ""c_t.csv"")"
"0","  "
"0","  all_list <- c(all_list, list(g_u_t_c_t))"
"0","}"
